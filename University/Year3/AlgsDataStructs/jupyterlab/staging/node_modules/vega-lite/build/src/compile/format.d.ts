import { DatumDef, FieldDef } from '../channeldef';
import { Config } from '../config';
import { TimeUnit } from '../timeunit';
import { Type } from '../type';
export declare const BIN_RANGE_DELIMITER = " \u2013 ";
export declare function setCustomFormatTypes(formatTypes: string[]): void;
export declare function isCustomFormatType(formatType: string): boolean;
export declare function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field, omitNumberFormatAndEmptyTimeFormat, omitTimeFormatConfig, isUTCScale }: {
    fieldOrDatumDef: FieldDef<string> | DatumDef<string>;
    format: string | object;
    formatType: string;
    expr?: 'datum' | 'parent' | 'datum.datum';
    normalizeStack?: boolean;
    config: Config;
    omitTimeFormatConfig?: boolean;
    field?: string;
    omitNumberFormatAndEmptyTimeFormat?: boolean;
    isUTCScale?: boolean;
}): {
    signal: string;
};
/**
 * Returns number format for a fieldDef
 */
export declare function numberFormat(type: Type, specifiedFormat: string | object, config: Config): string;
export declare function binFormatExpression(startField: string, endField: string, format: string | object, formatType: string, config: Config): string;
/**
 * Returns the time expression used for axis/legend labels or text mark for a temporal field
 */
export declare function timeFormatExpression(field: string, timeUnit: TimeUnit, format: string | object, rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels
isUTCScale: boolean, alwaysReturn?: boolean): string;
//# sourceMappingURL=format.d.ts.map