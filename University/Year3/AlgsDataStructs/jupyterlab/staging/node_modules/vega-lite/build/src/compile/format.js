import { isString } from 'vega-util';
import { isBinning } from '../bin';
import { channelDefType, isFieldDef, isFieldOrDatumDefForTimeFormat, isScaleFieldDef, vgField } from '../channeldef';
import { fieldValidPredicate } from '../predicate';
import { ScaleType } from '../scale';
import { formatExpression, normalizeTimeUnit } from '../timeunit';
import { QUANTITATIVE } from '../type';
import { datumDefToExpr } from './mark/encode/valueref';
export const BIN_RANGE_DELIMITER = ' \u2013 ';
let customFormatTypeIndex = new Set();
export function setCustomFormatTypes(formatTypes) {
    customFormatTypeIndex = new Set(formatTypes);
}
export function isCustomFormatType(formatType) {
    return formatType && formatType !== 'number' && formatType !== 'time' && customFormatTypeIndex.has(formatType);
}
function customFormatExpr({ formatType, field, format }) {
    return `${formatType}(${field}, ${JSON.stringify(format)})`;
}
export function formatSignalRef({ fieldOrDatumDef, format, formatType, expr, normalizeStack, config, field, omitNumberFormatAndEmptyTimeFormat, omitTimeFormatConfig, isUTCScale }) {
    var _a, _b;
    if (!field) {
        if (isFieldDef(fieldOrDatumDef)) {
            if (normalizeStack) {
                field = `${vgField(fieldOrDatumDef, { expr, suffix: 'end' })}-${vgField(fieldOrDatumDef, {
                    expr,
                    suffix: 'start'
                })}`;
            }
            else {
                field = vgField(fieldOrDatumDef, { expr });
            }
        }
        else {
            field = datumDefToExpr(fieldOrDatumDef);
        }
    }
    isUTCScale = isUTCScale !== null && isUTCScale !== void 0 ? isUTCScale : (isScaleFieldDef(fieldOrDatumDef) && ((_a = fieldOrDatumDef.scale) === null || _a === void 0 ? void 0 : _a.type) === ScaleType.UTC);
    const defaultTimeFormat = omitTimeFormatConfig ? null : config.timeFormat;
    if (isCustomFormatType(formatType)) {
        if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
            const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });
            return {
                signal: binFormatExpression(field, endField, format, formatType, config)
            };
        }
        return { signal: customFormatExpr({ formatType, format, field }) };
    }
    else if (formatType) {
        formatType = undefined; // drop unregistered custom formatType
    }
    if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
        const signal = timeFormatExpression(field, isFieldDef(fieldOrDatumDef) ? (_b = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _b === void 0 ? void 0 : _b.unit : undefined, format, defaultTimeFormat, isUTCScale, !omitNumberFormatAndEmptyTimeFormat);
        return signal ? { signal } : undefined;
    }
    else if (!omitNumberFormatAndEmptyTimeFormat) {
        format = numberFormat(channelDefType(fieldOrDatumDef), format, config);
        if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
            const endField = vgField(fieldOrDatumDef, { expr, binSuffix: 'end' });
            return {
                signal: binFormatExpression(field, endField, format, formatType, config)
            };
        }
        else if (format || channelDefType(fieldOrDatumDef) === 'quantitative') {
            return {
                signal: `${formatExpr(field, format)}`
            };
        }
        else {
            return { signal: `isValid(${field}) ? ${field} : ""+${field}` };
        }
    }
    return undefined;
}
/**
 * Returns number format for a fieldDef
 */
export function numberFormat(type, specifiedFormat, config) {
    // Specified format in axis/legend has higher precedence than fieldDef.format
    if (isString(specifiedFormat)) {
        return specifiedFormat;
    }
    if (type === QUANTITATIVE) {
        // we only apply the default if the field is quantitative
        return config.numberFormat;
    }
    return undefined;
}
function formatExpr(field, format) {
    return `format(${field}, "${format || ''}")`;
}
function binNumberFormatExpr(field, format, formatType, config) {
    var _a;
    if (isCustomFormatType(formatType)) {
        return customFormatExpr({ formatType, field, format });
    }
    return formatExpr(field, (_a = (isString(format) ? format : undefined)) !== null && _a !== void 0 ? _a : config.numberFormat);
}
export function binFormatExpression(startField, endField, format, formatType, config) {
    const start = binNumberFormatExpr(startField, format, formatType, config);
    const end = binNumberFormatExpr(endField, format, formatType, config);
    return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
/**
 * Returns the time expression used for axis/legend labels or text mark for a temporal field
 */
export function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels
isUTCScale, alwaysReturn = false) {
    if (!timeUnit || format) {
        // If there is not time unit, or if user explicitly specify format for axis/legend/text.
        format = isString(format) ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.
        if (format || alwaysReturn) {
            return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;
        }
        else {
            return undefined;
        }
    }
    else {
        return formatExpression(timeUnit, field, isUTCScale);
    }
}
//# sourceMappingURL=format.js.map