import { array } from 'vega-util';
import { isQuantitative } from '../../scale';
import { titlecase } from '../../util';
import { getStyleConfig } from '../common';
function getAxisConfigFromConfigTypes(configTypes, config) {
    // TODO: add special casing to add conditional value based on orient signal
    return Object.assign.apply(null, [{}, ...configTypes.map(configType => config[configType])]);
}
export function getAxisConfigs(channel, scaleType, orient, config) {
    const typeBasedConfigTypes = scaleType === 'band'
        ? ['axisDiscrete', 'axisBand']
        : scaleType === 'point'
            ? ['axisDiscrete', 'axisPoint']
            : isQuantitative(scaleType)
                ? ['axisQuantitative']
                : scaleType === 'time' || scaleType === 'utc'
                    ? ['axisTemporal']
                    : [];
    const axisChannel = channel === 'x' ? 'axisX' : 'axisY';
    const axisOrient = 'axis' + titlecase(orient); // axisTop, axisBottom, ...
    const vlOnlyConfigTypes = [
        // technically Vega does have axisBand, but if we make another separation here,
        // it will further introduce complexity in the code
        ...typeBasedConfigTypes,
        ...typeBasedConfigTypes.map(c => axisChannel + c.substr(4))
    ];
    const vgConfigTypes = ['axis', axisOrient, axisChannel];
    return {
        vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config),
        vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config),
        axisConfigStyle: getAxisConfigStyle([...vlOnlyConfigTypes, ...vgConfigTypes], config)
    };
}
export function getAxisConfigStyle(axisConfigTypes, config) {
    var _a;
    const toMerge = [{}];
    for (const configType of axisConfigTypes) {
        // TODO: add special casing to add conditional value based on orient signal
        let style = (_a = config[configType]) === null || _a === void 0 ? void 0 : _a.style;
        if (style) {
            style = array(style);
            for (const s of style) {
                toMerge.push(config.style[s]);
            }
        }
    }
    return Object.assign.apply(null, toMerge);
}
export function getAxisConfig(property, config, style, axisConfigs = {}) {
    var _a;
    const styleConfig = getStyleConfig(property, style, config.style);
    if (styleConfig !== undefined) {
        return {
            configFrom: 'style',
            configValue: styleConfig
        };
    }
    for (const configFrom of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle']) {
        if (((_a = axisConfigs[configFrom]) === null || _a === void 0 ? void 0 : _a[property]) !== undefined) {
            return { configFrom, configValue: axisConfigs[configFrom][property] };
        }
    }
    return {};
}
//# sourceMappingURL=config.js.map